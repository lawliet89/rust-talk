<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>What is Rust?</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-markdown>
				<textarea data-template>
						# What is Rust?

						Yong Wen Chua

						https://lawliet89.github.io/rust-talk/
					</textarea>
			</section>
			<section data-markdown>
				<textarea data-template>
						## Fast, safe, concurrent <!-- .element: class="fragment" data-fragment-index="1" -->

						## Pick Three <!-- .element: class="fragment" data-fragment-index="2" -->
					</textarea>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						## Rust

						 - Systems Programming Language
						 - Statically and strongly typed
						 - Compiled
						 - High performance â€” comparable to C
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						> This is one of the biggest revelations we've had in Rust's development -
						that there are vast audiences that want to write low level code but don't want
						to write C and C++. We see a lot of young programmers with backgrounds in Ruby
						and JavaScript getting into Rust, and creating their own high-performance
						systems software for the first time.

						Brian Anderson (Mozilla Rust Core Team Member)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Pains of Weak and Dynamic Type Systems

						- Hard to refactor
						- Hard to debug
						- Hard to design

						(Of course there are great
						[uses](https://softwareengineering.stackexchange.com/questions/122205/)
						for dynamic type systems)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Rust Safety Guarantees

						- No dereferencing null or dangling pointers
						- Reading uninitialised memory
						- No invalid primitives (e.g. a `bool` that is not 0 or 1; a non-UTF8 `str`)
						- No Data Race

						* There is `unsafe` too.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Rust _non_-guarantees

						- Race Condition
						- Deadlock
						- Memory Leaks
						- Failure to call destructors
						- Program Abortion

						> However any program that actually manages to do such a thing is probably incorrect.
						Rust provides lots of tools to make these things rare, but these problems are considered
						impractical to categorically prevent.


					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Memory Safety

						- Segmentation faults are hard to catch and debug
						- `Cloudbleed`, `StageFright`
						- Difficult to get right in C
						- Cumbersome to use in C++
						- [Read more](https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention)

					</textarea>
				</section>

				<section>
					<img src="https://cloud.githubusercontent.com/assets/983101/25533911/cc972f5c-2c64-11e7-8623-ef937fa045a5.png" />

					<aside class="notes">
						Tangentially related. I was working on a Pascal to ARM compiler (in C++), and then I said "fuck it" to manual memory management.
						So I used the (newfangled then) `shared_ptr` to try and side-step that. I don't have the numbers now, but `valgrind`
						still showed plenty of memory leaks. Probably due to circular references. But hey, I didn't get "many" segfaults. I
						just hoped there was something nicer to use.
					</aside>
				</section>
			</section>

			<section data-markdown>
				<textarea data-template>
					## Hello World

					```rust
					fn main() {
						println!("Hello, world!");
					}
					```

					[Run](https://play.integer32.com/?gist=c21e8e043c570c104afe927faa4de941)
				</textarea>
			</section>

			<section>
				<script type="text/javascript" src="https://asciinema.org/a/5t5ougvj179ribhjwrsg1mou6.js" id="asciicast-5t5ougvj179ribhjwrsg1mou6"
				 async></script>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						## Rust Ownership System (`borrowck`)


					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Remember C++'s pass by reference vs pass by value?
						``` rust
fn say_my_name(name: String) {
    println!("Your name is {}", name);
}

fn main() {
    let name = "Dovahkiin".to_string();

    say_my_name(name);

    // The next line won't compile
    // println!("Hello {}", name);
}
						```
						[Run](https://play.integer32.com/?gist=4cae497cb271314b41bae81cb1b35bf0)
					</textarea>
				</section>

				<section>
					<pre>
>error[E0382]: use of moved value: `name`
  --> src/main.rs:11:26
   |
8  |     say_my_name(name);
   |                 ---- value moved here
...
11 |     println!("Hello {}", name);
   |                          ^^^^ value used here after move
   |
   = note: move occurs because `name` has type `std::string::String`,
   which does not implement the `Copy` trait
</pre>

					<ul>
						<li>Values are moved by default</li>
						<li>Unless the `Copy` trait is implemented</li>
					</ul>
				</section>

				<section data-markdown>
					<textarea data-template>
						### We Need References

						> We can solve any problem by introducing an extra level of indirection

						-- David J. Wheeler
					</textarea>
				</section>

				<section>
					<table>
						<thead>
							<tr class="header">
								<th style="text-align: left;">Ownership enables:</th>
								<th style="text-align: left;">which removes:</th>
							</tr>
						</thead>
						<tbody>
							<tr class="odd">
								<td style="text-align: left;">RAII-style destructors</td>
								<td style="text-align: left;">a source of memory leaks (or fd leaks, etc)</td>
							</tr>
							<tr class="even">
								<td style="text-align: left;">no dangling pointers</td>
								<td style="text-align: left;">many resource management bugs</td>
							</tr>
							<tr class="odd">
								<td style="text-align: left;">no data races</td>
								<td style="text-align: left;">many multithreading heisenbugs</td>
							</tr>
						</tbody>
					</table>
					<div class="fragment">
						<blockquote>
							<p>Do I need to take ownership here, accepting the associated resource management
								responsibility? Would temporary access
								suffice?</p>
						</blockquote>
					</div>

					<aside class="notes">
						Good developers ask this already! Rust forces function signatures to encode the answers
						(and they are checked by the compiler). Can also use `Cow` for the caller to decide.
					</aside>
				</section>

				<section>
					<iframe width="560" height="315" src="https://www.youtube.com/embed/rEsoImv7vq8?rel=0" frameborder="0" allowfullscreen></iframe>
				</section>
			</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
				],
				history: true
			});
		</script>
</body>

</html>
